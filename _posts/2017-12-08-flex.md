---
layout: post
title: "Flex布局教程详解以及flex-grow与fle-shrink详细计算方法"
author: "hopeverse"
---

大多数时候，我们在进行网页布局时，并不能方便的将一些特殊布局给写成自己想要的样子，更多的时候需要将```position```、```float```等等一些属性来加以辅助，感觉特别不顺手。

那么在09年的时候，w3c提出了Flex布局，主要是可以简单，方便的实现各种响应式布局。现如今对于浏览器的支持已经比较好了，而且现也多用于移动端页面的开发。


<br/>

### 什么是Flex布局？

Flex是一种布局方式叫做弹性布局，能够给盒子提供最大的灵活性，同时可以给任何的盒子指定为flex布局

通过在父盒子上来指定为flex ，当然行内元素也可以指定为flex布局

```
.main {
    display:flex;       // 块级元素指定flex布局
}
```

```
.mian-inline {
    display:inline-flex;    // 行内元素指定flex布局
}
```

![不加flex之前](/images/posts/flex/flexq.png)
![加flex之后](/images/posts/flex/flexh.png)

### flex的概念

Flex是一种伸缩布局方式，大家多成为Flex容器。所以只要使用了flex的都成为flex容器，那么它的子元素都是它的容器元素，也叫它的容器项目。

![flexzhou](/images/posts/flex/flexz.png)

关于flex轴，它其中有几个术语

主轴(main axis)： 指的是Flex容器项目排列方向，默认为水平方向为主轴，那么当指定为竖直方向排列容器项目时，主轴为垂直方向的。<br/>

交叉轴(cross axis): 指的是根据主轴的方向，所垂直于主轴方向的，为交叉轴。同上，如若定义的容器项目排列方向不同，交叉轴也是不同的。<br/>

主轴起点(main start): 指的是主轴方向起点位置<br/>

主轴终点(main end): 指的是主轴方向终点位置<br/>

交叉轴起点(cross start): 指的是交叉轴方向起点位置<br/>

交叉轴终点(cross end): 指的是交叉轴轴方向终点位置<br/>

注意！ 关于主轴和交叉轴这两个概念，一定需要理解清楚。最初学习Flex容易忽视主轴和交叉轴的概念，而导致后面的概念混乱。 主轴和交叉轴他们并不是不变的，后面的属性会说。

<br/>

### flex的属性

#### flex-direcion

此属性决定主轴的方向，row为横向主轴，column为竖直方向为主轴。结合上方
主轴和交叉轴概念以理解。所以根据主轴定义的方向，交叉轴的方向也会相应改
变。

![direction](/images/posts/flex/direction.png)

```
flex-direction : row;            // 按行顺序排列   

flex-direction : row-reverse;    // 按行顺序反向排列  

flex-direction : column;         // 按列顺序排列

flex-direction : column-reverse; // 按列顺序反向排列


```

<br/>

#### flex-wrap

此属性决定flex项目，在一行或者一列顺序下，如果不够空间全部放下，是否换行继续排列，还是继续强制在主轴方向下排列下去。

![wrap](/images/posts/flex/wrap.png)


```
flex-wrap：nowrap;     // 不换行

flex-wrap：wrap;       // 换行

flex-wrap：wrap-reverse  // 不仅换行，还颠倒换行之后的顺序，换行的
内容排在主轴第一排
```

<br/>

#### flex-flow

此属性是```flex-direction```和```flex-wrap```的简写方法

```
.main {
   
    flex-flow：<flex-direction> <flex-wrap> ;

    //默认是flex-flow：row nowrap;
}

```

<br/>

#### justify-content

此属性决定在主轴上的对齐方式，主轴属于不同的方向，那么对齐方式会有相应的改变。

![justify-content](/images/posts/flex/justify.png)

```
justify-content：flex-start;      // 主轴起点对齐

justify-content：flex-end;        // 主轴终点对齐

justify-content：center;          // 主轴居中对齐

justify-content：space-between;   // 主轴两端对齐，各项目中间距离
                                     相等

justify-content：space-around;    // 两端距离相等，中间项目距离大
                                     两端距离一倍

justify-content：initial;         // 默认值

```

<br/>

#### align-items

此属性定义在交叉轴上的对齐方式

![items](/images/posts/flex/items.png)

```
align-items：flex-start;       // 交叉轴上起点位置对齐
align-items：flex-end;         // 交叉轴上终点位置对齐
align-items：stretch;          // 高度未定义或者auto时，交叉轴上项目撑满交叉轴空间
align-items：baseline;         // 交叉轴上文字基线对齐
align-items：center;           // 交叉轴上居中对齐

```

<br/>

#### align-content

此属性决定当项目变为多轴(相当于flex-wrap:wrap;效果，或者叫多行更好理解)之后的对齐方式，只有一根轴线的话不起作用

```
.main {
    display：flex;
    flex-flow：row wrap;
    // 下方图例的基本css代码
}

```

![aligncon](/images/posts/flex/aligncon.png)


```
align-content：stretch;
align-content：center;
align-content：flex-start;
align-content：flex-end;
align-content：space-between;
align-content：space-around;

```

<br/>

### Flex单项目属性

#### order

此属性决定着单个flex项目的顺序，默认值为0。另外，数值越小的，排在越前，数值越大的，排在越靠后，当数值相等时，按照结构顺序进行排列。

![order](/images/posts/flex/order.png)

```
<div id="main">
  <div style="background-color:coral;order:1;">1</div>
  <div style="background-color:lightblue;order: -2;">-2</div>
  <div style="background-color:khaki;order: 3;">3</div>
</div>

// 这是上方图例结构，当order数值相同时，不管正负值都按照div的顺序排列

```

<br/>

#### align-self

此属性决定着单个flex项目，能够独立出来设置对齐方式。并且能够覆盖align-items属性，默认值为auto的话，那么则继承父元素的align-items属性，如果没有父元素，等同于stretch。

![self](/images/posts/flex/self.png)

```
align-self: auto | flex-start | flex-end | center | baseline | stretch;

// 属性值效果，同前面各类属性值效果差不多，只是它能单独控制单个项目的对齐方式

```

<br/>

#### flex-grow

此属性决定着单个flex项目的方法比例，默认值为0。

在说这个属性之前，先加上一点小细节。flex容器的高度会自动被最高的一个子元素撑开，同时其它子元素的高度也会被拉到跟flex容器一样高，而如果给flex容器设置了高度，而所有子元素的高度设置为 auto ，所有的子元素也都会自动拉伸成跟父元素一样高。（通俗来说就是，普通div，内部盒子的高度如果是auto，那么是根据内容撑开的。但是设置了display:flex之后，当项目未设置高度或者高度为auto，内部无内容，都能够自动撑开到同父元素一样的高度）

当仅仅只给一个flex子项目，设置flex-grow:1;时将占满所有剩余空间。

另外，如果不给 flex 子元素设置宽度和 flex-grow，它会根据文字或者内容尽可能的窄。

![grow](/images/posts/flex/grow.png)

```
<div id="main">
  <div style="background-color:coral;width: 100px;flex-grow:2">2倍</div>
  <div style="background-color:lightblue;width: 200px;flex-grow: 2;">2倍</div>
  <div style="background-color:khaki;width: 150px;flex-grow: 1;">1倍</div>
</div>

// main设置宽度为800px;前三个div最初设置为100px,200px,150px。那么通过flex-grow设置完之后，最后三个div宽度分别为240px,340px,220px;

```

那么可以得出计算公式：

```
flex容器剩余宽度 * 你要放大的倍数/flex容器子项目所有放大倍数之和

例如上述例子：剩余空间(800-100-200-150)*(flex-grow)/5 最后得出放大倍数
之后给自己原来的width再添加多少px的像素

所以最后每一个div的宽度=原本的宽度+放大倍数之后得到剩余空间比例的宽度

```

当然，上述的公式是在你flex子项目定宽之后，算法才有效。如果不定宽，那么会根据flex子项目中的内容的多少，来决定具体放大倍数之后有多少像素宽，可以在控制台中具体看看改变内容之后，子项目占据了多少像素。

所以的元素的flex-grow之和只要大于等于1的话，公式都有效。但另外还有种情况，就是当flex-grow之和小于1的时候，剩余空间不会全部分配给各个元素，并且他们最后除的不同于大于等于1的情况，当放大倍数相加小于1时，最后不管如何也是除以1。




















如需转载，请注明出处，谢谢！




 
[https://liutianzhu.me](https://liutianzhu.me)
